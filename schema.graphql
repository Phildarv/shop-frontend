type Address implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: Country!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

type Adjustment {
  adjustmentSource: String!
  type: AdjustmentType!
  description: String!
  amount: Int!
}

enum AdjustmentType {
  TAX
  PROMOTION
  SHIPPING
  REFUND
  TAX_REFUND
  PROMOTION_REFUND
  SHIPPING_REFUND
}

type Administrator implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  emailAddress: String!
  user: User!
}

type AdministratorList implements PaginatedList {
  items: [Administrator!]!
  totalItems: Int!
}

type Asset implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  type: AssetType!
  fileSize: Int!
  mimeType: String!
  width: Int!
  height: Int!
  source: String!
  preview: String!
  focalPoint: Coordinate
}

type AssetList implements PaginatedList {
  items: [Asset!]!
  totalItems: Int!
}

enum AssetType {
  IMAGE
  VIDEO
  BINARY
}

input AuthenticationInput {
  native: NativeAuthInput
}

type AuthenticationMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  strategy: String!
}

type BooleanCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
}

input BooleanOperators {
  eq: Boolean
}

type BulkDiscount {
  productVariant: ProductVariant!
  quantity: Int!
  price: Int!
}

type Cancellation implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  orderLine: OrderLine!
}

type Channel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  token: String!
  defaultTaxZone: Zone
  defaultShippingZone: Zone
  defaultLanguageCode: LanguageCode!
  currencyCode: CurrencyCode!
  pricesIncludeTax: Boolean!
}

type Collection implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode
  name: String!
  slug: String!
  breadcrumbs: [CollectionBreadcrumb!]!
  position: Int!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  parent: Collection
  children: [Collection!]
  filters: [ConfigurableOperation!]!
  translations: [CollectionTranslation!]!
  productVariants(options: ProductVariantListOptions): ProductVariantList!
  links: [CollectionLink!]!
  products: [Product!]!
  customFields: CollectionCustomFields
}

type CollectionBreadcrumb {
  id: ID!
  name: String!
  slug: String!
}

type CollectionCustomFields {
  seoDescription: String
}

input CollectionFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  position: NumberOperators
  description: StringOperators
  seoDescription: StringOperators
}

type CollectionLink {
  id: ID!
  collection: Collection!
  collectionId: ID!
  icon: CollectionLinkType!
  name: String!
  url: String!
}

type CollectionLinkTranslation {
  id: ID!
  languageCode: LanguageCode!
  name: ID!
  url: String!
}

enum CollectionLinkType {
  PDF
  VIDEO
  LINK
}

type CollectionList implements PaginatedList {
  items: [Collection!]!
  totalItems: Int!
}

input CollectionListOptions {
  skip: Int
  take: Int
  sort: CollectionSortParameter
  filter: CollectionFilterParameter
}

input CollectionSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  position: SortOrder
  description: SortOrder
  seoDescription: SortOrder
}

type CollectionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ConfigArg {
  name: String!
  value: String!
}

type ConfigArgDefinition {
  name: String!
  type: String!
  list: Boolean!
  label: String
  description: String
  ui: JSON
}

input ConfigArgInput {
  name: String!
  value: String!
}

type ConfigurableOperation {
  code: String!
  args: [ConfigArg!]!
}

type ConfigurableOperationDefinition {
  code: String!
  args: [ConfigArgDefinition!]!
  description: String!
}

input ConfigurableOperationInput {
  code: String!
  arguments: [ConfigArgInput!]!
}

type Coordinate {
  x: Float!
  y: Float!
}

type Country implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  enabled: Boolean!
  translations: [CountryTranslation!]!
}

type CountryList implements PaginatedList {
  items: [Country!]!
  totalItems: Int!
}

type CountryTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

input CreateAddressInput {
  fullName: String
  company: String
  streetLine1: String!
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String!
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

input CreateCustomerInput {
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  customFields: JSON
}

# @description
# ISO 4217 currency code
#
# @docsCategory common
enum CurrencyCode {
  # United Arab Emirates dirham
  AED

  # Afghan afghani
  AFN

  # Albanian lek
  ALL

  # Armenian dram
  AMD

  # Netherlands Antillean guilder
  ANG

  # Angolan kwanza
  AOA

  # Argentine peso
  ARS

  # Australian dollar
  AUD

  # Aruban florin
  AWG

  # Azerbaijani manat
  AZN

  # Bosnia and Herzegovina convertible mark
  BAM

  # Barbados dollar
  BBD

  # Bangladeshi taka
  BDT

  # Bulgarian lev
  BGN

  # Bahraini dinar
  BHD

  # Burundian franc
  BIF

  # Bermudian dollar
  BMD

  # Brunei dollar
  BND

  # Boliviano
  BOB

  # Brazilian real
  BRL

  # Bahamian dollar
  BSD

  # Bhutanese ngultrum
  BTN

  # Botswana pula
  BWP

  # Belarusian ruble
  BYN

  # Belize dollar
  BZD

  # Canadian dollar
  CAD

  # Congolese franc
  CDF

  # Swiss franc
  CHF

  # Chilean peso
  CLP

  # Renminbi (Chinese) yuan
  CNY

  # Colombian peso
  COP

  # Costa Rican colon
  CRC

  # Cuban convertible peso
  CUC

  # Cuban peso
  CUP

  # Cape Verde escudo
  CVE

  # Czech koruna
  CZK

  # Djiboutian franc
  DJF

  # Danish krone
  DKK

  # Dominican peso
  DOP

  # Algerian dinar
  DZD

  # Egyptian pound
  EGP

  # Eritrean nakfa
  ERN

  # Ethiopian birr
  ETB

  # Euro
  EUR

  # Fiji dollar
  FJD

  # Falkland Islands pound
  FKP

  # Pound sterling
  GBP

  # Georgian lari
  GEL

  # Ghanaian cedi
  GHS

  # Gibraltar pound
  GIP

  # Gambian dalasi
  GMD

  # Guinean franc
  GNF

  # Guatemalan quetzal
  GTQ

  # Guyanese dollar
  GYD

  # Hong Kong dollar
  HKD

  # Honduran lempira
  HNL

  # Croatian kuna
  HRK

  # Haitian gourde
  HTG

  # Hungarian forint
  HUF

  # Indonesian rupiah
  IDR

  # Israeli new shekel
  ILS

  # Indian rupee
  INR

  # Iraqi dinar
  IQD

  # Iranian rial
  IRR

  # Icelandic króna
  ISK

  # Jamaican dollar
  JMD

  # Jordanian dinar
  JOD

  # Japanese yen
  JPY

  # Kenyan shilling
  KES

  # Kyrgyzstani som
  KGS

  # Cambodian riel
  KHR

  # Comoro franc
  KMF

  # North Korean won
  KPW

  # South Korean won
  KRW

  # Kuwaiti dinar
  KWD

  # Cayman Islands dollar
  KYD

  # Kazakhstani tenge
  KZT

  # Lao kip
  LAK

  # Lebanese pound
  LBP

  # Sri Lankan rupee
  LKR

  # Liberian dollar
  LRD

  # Lesotho loti
  LSL

  # Libyan dinar
  LYD

  # Moroccan dirham
  MAD

  # Moldovan leu
  MDL

  # Malagasy ariary
  MGA

  # Macedonian denar
  MKD

  # Myanmar kyat
  MMK

  # Mongolian tögrög
  MNT

  # Macanese pataca
  MOP

  # Mauritanian ouguiya
  MRU

  # Mauritian rupee
  MUR

  # Maldivian rufiyaa
  MVR

  # Malawian kwacha
  MWK

  # Mexican peso
  MXN

  # Malaysian ringgit
  MYR

  # Mozambican metical
  MZN

  # Namibian dollar
  NAD

  # Nigerian naira
  NGN

  # Nicaraguan córdoba
  NIO

  # Norwegian krone
  NOK

  # Nepalese rupee
  NPR

  # New Zealand dollar
  NZD

  # Omani rial
  OMR

  # Panamanian balboa
  PAB

  # Peruvian sol
  PEN

  # Papua New Guinean kina
  PGK

  # Philippine peso
  PHP

  # Pakistani rupee
  PKR

  # Polish złoty
  PLN

  # Paraguayan guaraní
  PYG

  # Qatari riyal
  QAR

  # Romanian leu
  RON

  # Serbian dinar
  RSD

  # Russian ruble
  RUB

  # Rwandan franc
  RWF

  # Saudi riyal
  SAR

  # Solomon Islands dollar
  SBD

  # Seychelles rupee
  SCR

  # Sudanese pound
  SDG

  # Swedish krona/kronor
  SEK

  # Singapore dollar
  SGD

  # Saint Helena pound
  SHP

  # Sierra Leonean leone
  SLL

  # Somali shilling
  SOS

  # Surinamese dollar
  SRD

  # South Sudanese pound
  SSP

  # São Tomé and Príncipe dobra
  STN

  # Salvadoran colón
  SVC

  # Syrian pound
  SYP

  # Swazi lilangeni
  SZL

  # Thai baht
  THB

  # Tajikistani somoni
  TJS

  # Turkmenistan manat
  TMT

  # Tunisian dinar
  TND

  # Tongan paʻanga
  TOP

  # Turkish lira
  TRY

  # Trinidad and Tobago dollar
  TTD

  # New Taiwan dollar
  TWD

  # Tanzanian shilling
  TZS

  # Ukrainian hryvnia
  UAH

  # Ugandan shilling
  UGX

  # United States dollar
  USD

  # Uruguayan peso
  UYU

  # Uzbekistan som
  UZS

  # Venezuelan bolívar soberano
  VES

  # Vietnamese đồng
  VND

  # Vanuatu vatu
  VUV

  # Samoan tala
  WST

  # CFA franc BEAC
  XAF

  # East Caribbean dollar
  XCD

  # CFA franc BCEAO
  XOF

  # CFP franc (franc Pacifique)
  XPF

  # Yemeni rial
  YER

  # South African rand
  ZAR

  # Zambian kwacha
  ZMW

  # Zimbabwean dollar
  ZWL
}

type CurrentUser {
  id: ID!
  identifier: String!
  channels: [CurrentUserChannel!]!
}

type CurrentUserChannel {
  id: ID!
  token: String!
  code: String!
  permissions: [Permission!]!
}

type Customer implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
  firstName: String!
  lastName: String!
  phoneNumber: String
  emailAddress: String!
  addresses: [Address!]
  orders(options: OrderListOptions): OrderList!
  user: User
  resellerDiscounts: [ResellerDiscount!]!
  customFields: JSON
}

input CustomerFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  title: StringOperators
  firstName: StringOperators
  lastName: StringOperators
  phoneNumber: StringOperators
  emailAddress: StringOperators
}

type CustomerGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  customers(options: CustomerListOptions): CustomerList!
}

type CustomerList implements PaginatedList {
  items: [Customer!]!
  totalItems: Int!
}

input CustomerListOptions {
  skip: Int
  take: Int
  sort: CustomerSortParameter
  filter: CustomerFilterParameter
}

input CustomerSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  title: SortOrder
  firstName: SortOrder
  lastName: SortOrder
  phoneNumber: SortOrder
  emailAddress: SortOrder
}

interface CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
}

union CustomFieldConfig =
    StringCustomFieldConfig
  | LocaleStringCustomFieldConfig
  | IntCustomFieldConfig
  | FloatCustomFieldConfig
  | BooleanCustomFieldConfig
  | DateTimeCustomFieldConfig

type CustomFields {
  Address: [CustomFieldConfig!]!
  Collection: [CustomFieldConfig!]!
  Customer: [CustomFieldConfig!]!
  Facet: [CustomFieldConfig!]!
  FacetValue: [CustomFieldConfig!]!
  GlobalSettings: [CustomFieldConfig!]!
  Order: [CustomFieldConfig!]!
  OrderLine: [CustomFieldConfig!]!
  Product: [CustomFieldConfig!]!
  ProductOption: [CustomFieldConfig!]!
  ProductOptionGroup: [CustomFieldConfig!]!
  ProductVariant: [CustomFieldConfig!]!
  User: [CustomFieldConfig!]!
  ShippingMethod: [CustomFieldConfig!]!
}

input DateOperators {
  eq: DateTime
  before: DateTime
  after: DateTime
  between: DateRange
}

input DateRange {
  start: DateTime!
  end: DateTime!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
# `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
# 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# Expects the same validation formats as the `<input type="datetime-local">` HTML element.
# See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes
type DateTimeCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: String
  max: String
  step: Int
}

type DeletionResponse {
  result: DeletionResult!
  message: String
}

enum DeletionResult {
  # The entity was successfully deleted
  DELETED

  # Deletion did not take place, reason given in message
  NOT_DELETED
}

type Facet implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  code: String!
  values: [FacetValue!]!
  translations: [FacetTranslation!]!
  customFields: JSON
}

type FacetList implements PaginatedList {
  items: [Facet!]!
  totalItems: Int!
}

type FacetTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FacetValue implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  facet: Facet!
  name: String!
  code: String!
  translations: [FacetValueTranslation!]!
  customFields: JSON
}

# Which FacetValues are present in the products returned
# by the search, and in what quantity.
type FacetValueResult {
  facetValue: FacetValue!
  count: Int!
}

type FacetValueTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type FloatCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: Float
  max: Float
  step: Float
}

type Fulfillment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  orderItems: [OrderItem!]!
  method: String!
  trackingCode: String
}

type GlobalSettings {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  availableLanguages: [LanguageCode!]!
  trackInventory: Boolean!
  serverConfig: ServerConfig!
  customFields: JSON
}

type HistoryEntry implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublic: Boolean!
  type: HistoryEntryType!
  administrator: Administrator
  data: JSON!
}

input HistoryEntryFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  isPublic: BooleanOperators
  type: StringOperators
}

type HistoryEntryList implements PaginatedList {
  items: [HistoryEntry!]!
  totalItems: Int!
}

input HistoryEntryListOptions {
  skip: Int
  take: Int
  sort: HistoryEntrySortParameter
  filter: HistoryEntryFilterParameter
}

input HistoryEntrySortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

enum HistoryEntryType {
  CUSTOMER_REGISTERED
  CUSTOMER_VERIFIED
  CUSTOMER_DETAIL_UPDATED
  CUSTOMER_ADDED_TO_GROUP
  CUSTOMER_REMOVED_FROM_GROUP
  CUSTOMER_ADDRESS_CREATED
  CUSTOMER_ADDRESS_UPDATED
  CUSTOMER_ADDRESS_DELETED
  CUSTOMER_PASSWORD_UPDATED
  CUSTOMER_PASSWORD_RESET_REQUESTED
  CUSTOMER_PASSWORD_RESET_VERIFIED
  CUSTOMER_EMAIL_UPDATE_REQUESTED
  CUSTOMER_EMAIL_UPDATE_VERIFIED
  CUSTOMER_NOTE
  ORDER_STATE_TRANSITION
  ORDER_PAYMENT_TRANSITION
  ORDER_FULLFILLMENT
  ORDER_CANCELLATION
  ORDER_REFUND_TRANSITION
  ORDER_NOTE
  ORDER_COUPON_APPLIED
  ORDER_COUPON_REMOVED
}

type ImportInfo {
  errors: [String!]
  processed: Int!
  imported: Int!
}

type IntCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  min: Int
  max: Int
  step: Int
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# @description
# Languages in the form of a ISO 639-1 language code with optional
# region or script modifier (e.g. de_AT). The selection available is based
# on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)
# and includes the major spoken languages of the world and any widely-used variants.
#
# @docsCategory common
enum LanguageCode {
  # Afrikaans
  af

  # Akan
  ak

  # Albanian
  sq

  # Amharic
  am

  # Arabic
  ar

  # Armenian
  hy

  # Assamese
  as

  # Azerbaijani
  az

  # Bambara
  bm

  # Bangla
  bn

  # Basque
  eu

  # Belarusian
  be

  # Bosnian
  bs

  # Breton
  br

  # Bulgarian
  bg

  # Burmese
  my

  # Catalan
  ca

  # Chechen
  ce

  # Chinese
  zh

  # Simplified Chinese
  zh_Hans

  # Traditional Chinese
  zh_Hant

  # Church Slavic
  cu

  # Cornish
  kw

  # Corsican
  co

  # Croatian
  hr

  # Czech
  cs

  # Danish
  da

  # Dutch
  nl

  # Flemish
  nl_BE

  # Dzongkha
  dz

  # English
  en

  # Australian English
  en_AU

  # Canadian English
  en_CA

  # British English
  en_GB

  # American English
  en_US

  # Esperanto
  eo

  # Estonian
  et

  # Ewe
  ee

  # Faroese
  fo

  # Finnish
  fi

  # French
  fr

  # Canadian French
  fr_CA

  # Swiss French
  fr_CH

  # Fulah
  ff

  # Galician
  gl

  # Ganda
  lg

  # Georgian
  ka

  # German
  de

  # Austrian German
  de_AT

  # Swiss High German
  de_CH

  # Greek
  el

  # Gujarati
  gu

  # Haitian Creole
  ht

  # Hausa
  ha

  # Hebrew
  he

  # Hindi
  hi

  # Hungarian
  hu

  # Icelandic
  is

  # Igbo
  ig

  # Indonesian
  id

  # Interlingua
  ia

  # Irish
  ga

  # Italian
  it

  # Japanese
  ja

  # Javanese
  jv

  # Kalaallisut
  kl

  # Kannada
  kn

  # Kashmiri
  ks

  # Kazakh
  kk

  # Khmer
  km

  # Kikuyu
  ki

  # Kinyarwanda
  rw

  # Korean
  ko

  # Kurdish
  ku

  # Kyrgyz
  ky

  # Lao
  lo

  # Latin
  la

  # Latvian
  lv

  # Lingala
  ln

  # Lithuanian
  lt

  # Luba-Katanga
  lu

  # Luxembourgish
  lb

  # Macedonian
  mk

  # Malagasy
  mg

  # Malay
  ms

  # Malayalam
  ml

  # Maltese
  mt

  # Manx
  gv

  # Maori
  mi

  # Marathi
  mr

  # Mongolian
  mn

  # Nepali
  ne

  # North Ndebele
  nd

  # Northern Sami
  se

  # Norwegian Bokmål
  nb

  # Norwegian Nynorsk
  nn

  # Nyanja
  ny

  # Odia
  or

  # Oromo
  om

  # Ossetic
  os

  # Pashto
  ps

  # Persian
  fa

  # Dari
  fa_AF

  # Polish
  pl

  # Portuguese
  pt

  # Brazilian Portuguese
  pt_BR

  # European Portuguese
  pt_PT

  # Punjabi
  pa

  # Quechua
  qu

  # Romanian
  ro

  # Moldavian
  ro_MD

  # Romansh
  rm

  # Rundi
  rn

  # Russian
  ru

  # Samoan
  sm

  # Sango
  sg

  # Sanskrit
  sa

  # Scottish Gaelic
  gd

  # Serbian
  sr

  # Shona
  sn

  # Sichuan Yi
  ii

  # Sindhi
  sd

  # Sinhala
  si

  # Slovak
  sk

  # Slovenian
  sl

  # Somali
  so

  # Southern Sotho
  st

  # Spanish
  es

  # European Spanish
  es_ES

  # Mexican Spanish
  es_MX

  # Sundanese
  su

  # Swahili
  sw

  # Congo Swahili
  sw_CD

  # Swedish
  sv

  # Tajik
  tg

  # Tamil
  ta

  # Tatar
  tt

  # Telugu
  te

  # Thai
  th

  # Tibetan
  bo

  # Tigrinya
  ti

  # Tongan
  to

  # Turkish
  tr

  # Turkmen
  tk

  # Ukrainian
  uk

  # Urdu
  ur

  # Uyghur
  ug

  # Uzbek
  uz

  # Vietnamese
  vi

  # Volapük
  vo

  # Welsh
  cy

  # Western Frisian
  fy

  # Wolof
  wo

  # Xhosa
  xh

  # Yiddish
  yi

  # Yoruba
  yo

  # Zulu
  zu
}

type LocaleStringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  pattern: String
}

type LocalizedString {
  languageCode: LanguageCode!
  value: String!
}

enum LogicalOperator {
  AND
  OR
}

type LoginResult {
  user: CurrentUser!
}

type Mutation {
  # Adds an item to the order. If custom fields are defined on the OrderLine
  # entity, a third argument 'customFields' will be available.
  addItemToOrder(productVariantId: ID!, quantity: Int!): Order

  # Remove an OrderLine from the Order
  removeOrderLine(orderLineId: ID!): Order

  # Remove all OrderLine from the Order
  removeAllOrderLines: Order

  # Adjusts an OrderLine. If custom fields are defined on the OrderLine entity, a
  # third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available.
  adjustOrderLine(orderLineId: ID!, quantity: Int): Order

  # Applies the given coupon code to the active Order
  applyCouponCode(couponCode: String!): Order

  # Removes the given coupon code from the active Order
  removeCouponCode(couponCode: String!): Order

  # Transitions an Order to a new state. Valid next states can be found by querying `nextOrderStates`
  transitionOrderToState(state: String!): Order

  # Sets the shipping address for this order
  setOrderShippingAddress(input: CreateAddressInput!): Order

  # Sets the billing address for this order
  setOrderBillingAddress(input: CreateAddressInput!): Order

  # Allows any custom fields to be set for the active order
  setOrderCustomFields(input: UpdateOrderInput!): Order

  # Sets the shipping method by id, which can be obtained with the `eligibleShippingMethods` query
  setOrderShippingMethod(shippingMethodId: ID!): Order

  # Add a Payment to the Order
  addPaymentToOrder(input: PaymentInput!): Order

  # Set the Customer for the Order. Required only if the Customer is not currently logged in
  setCustomerForOrder(input: CreateCustomerInput!): Order

  # Authenticates the user using the native authentication strategy. This mutation
  # is an alias for `authenticate({ native: { ... }})`
  login(username: String!, password: String!, rememberMe: Boolean): LoginResult!

  # Authenticates the user using a named authentication strategy
  authenticate(input: AuthenticationInput!, rememberMe: Boolean): LoginResult!

  # End the current authenticated session
  logout: Boolean!

  # Regenerate and send a verification token for a new Customer registration. Only
  # applicable if `authOptions.requireVerification` is set to true.
  refreshCustomerVerification(emailAddress: String!): Boolean!

  # Register a Customer account with the given credentials. There are three possible registration flows:
  #
  # _If `authOptions.requireVerification` is set to `true`:_
  #
  # 1. **The Customer is registered _with_ a password**. A verificationToken will
  # be created (and typically emailed to the Customer). That
  #    verificationToken would then be passed to the `verifyCustomerAccount`
  # mutation _without_ a password. The Customer is then
  #    verified and authenticated in one step.
  # 2. **The Customer is registered _without_ a password**. A verificationToken
  # will be created (and typically emailed to the Customer). That
  #    verificationToken would then be passed to the `verifyCustomerAccount`
  # mutation _with_ the chosed password of the Customer. The Customer is then
  #    verified and authenticated in one step.
  #
  # _If `authOptions.requireVerification` is set to `false`:_
  #
  # 3. The Customer _must_ be registered _with_ a password. No further action is
  # needed - the Customer is able to authenticate immediately.
  registerCustomerAccount(input: RegisterCustomerInput!): Boolean!

  # Update an existing Customer
  updateCustomer(input: UpdateCustomerInput!): Customer!

  # Create a new Customer Address
  createCustomerAddress(input: CreateAddressInput!): Address!

  # Update an existing Address
  updateCustomerAddress(input: UpdateAddressInput!): Address!

  # Delete an existing Address
  deleteCustomerAddress(id: ID!): Boolean!

  # Verify a Customer email address with the token sent to that address. Only
  # applicable if `authOptions.requireVerification` is set to true.
  #
  # If the Customer was not registered with a password in the `registerCustomerAccount` mutation, the a password _must_ be
  # provided here.
  verifyCustomerAccount(token: String!, password: String): LoginResult!

  # Update the password of the active Customer
  updateCustomerPassword(
    currentPassword: String!
    newPassword: String!
  ): Boolean

  # Request to update the emailAddress of the active Customer. If `authOptions.requireVerification` is enabled
  # (as is the default), then the `identifierChangeToken` will be assigned to the current User and
  # a IdentifierChangeRequestEvent will be raised. This can then be used e.g. by the EmailPlugin to email
  # that verification token to the Customer, which is then used to verify the change of email address.
  requestUpdateCustomerEmailAddress(
    password: String!
    newEmailAddress: String!
  ): Boolean

  # Confirm the update of the emailAddress with the provided token, which has been generated by the
  # `requestUpdateCustomerEmailAddress` mutation.
  updateCustomerEmailAddress(token: String!): Boolean

  # Requests a password reset email to be sent
  requestPasswordReset(emailAddress: String!): Boolean

  # Resets a Customer's password based on the provided token
  resetPassword(token: String!, password: String!): LoginResult!
}

input NativeAuthInput {
  username: String!
  password: String!
}

interface Node {
  id: ID!
}

input NumberOperators {
  eq: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  between: NumberRange
}

input NumberRange {
  start: Float!
  end: Float!
}

type Order implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  # A unique code for the Order
  code: String!
  state: String!

  # An order is active as long as the payment process has not been completed
  active: Boolean!
  customer: Customer
  shippingAddress: OrderAddress
  billingAddress: OrderAddress
  lines: [OrderLine!]!

  # Order-level adjustments to the order total, such as discounts from promotions
  adjustments: [Adjustment!]!
  couponCodes: [String!]!

  # Promotions applied to the order. Only gets populated after the payment process has completed.
  promotions: [Promotion!]!
  payments: [Payment!]
  fulfillments: [Fulfillment!]
  subTotalBeforeTax: Int!

  # The subTotal is the total of the OrderLines, before order-level promotions and shipping has been applied.
  subTotal: Int!
  currencyCode: CurrencyCode!
  shipping: Int!
  shippingWithTax: Int!
  shippingMethod: ShippingMethod
  totalBeforeTax: Int!
  total: Int!
  history(options: HistoryEntryListOptions): HistoryEntryList!
  customFields: JSON
}

type OrderAddress {
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  country: String
  countryCode: String
  phoneNumber: String
}

input OrderFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  code: StringOperators
  state: StringOperators
  active: BooleanOperators
  subTotalBeforeTax: NumberOperators
  subTotal: NumberOperators
  currencyCode: StringOperators
  shipping: NumberOperators
  shippingWithTax: NumberOperators
  totalBeforeTax: NumberOperators
  total: NumberOperators
}

type OrderItem implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cancelled: Boolean!
  unitPrice: Int!
  unitPriceWithTax: Int!
  unitPriceIncludesTax: Boolean!
  taxRate: Float!
  adjustments: [Adjustment!]!
  fulfillment: Fulfillment
  refundId: ID
}

type OrderLine implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  featuredAsset: Asset
  unitPrice: Int!
  unitPriceWithTax: Int!
  quantity: Int!
  items: [OrderItem!]!
  totalPrice: Int!
  adjustments: [Adjustment!]!
  order: Order!
  customFields: JSON
}

type OrderList implements PaginatedList {
  items: [Order!]!
  totalItems: Int!
}

input OrderListOptions {
  skip: Int
  take: Int
  sort: OrderSortParameter
  filter: OrderFilterParameter
}

type OrderProcessState {
  name: String!
  to: [String!]!
}

input OrderSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  code: SortOrder
  state: SortOrder
  subTotalBeforeTax: SortOrder
  subTotal: SortOrder
  shipping: SortOrder
  shippingWithTax: SortOrder
  totalBeforeTax: SortOrder
  total: SortOrder
}

interface PaginatedList {
  items: [Node!]!
  totalItems: Int!
}

type Payment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  method: String!
  amount: Int!
  state: String!
  transactionId: String
  errorMessage: String
  refunds: [Refund!]!
  metadata: JSON
}

# Passed as input to the `addPaymentToOrder` mutation.
input PaymentInput {
  # This field should correspond to the `code` property of a PaymentMethodHandler.
  method: String!

  # This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method
  # as the "metadata" argument. For example, it could contain an ID for the payment and other
  # data generated by the payment provider.
  metadata: JSON!
}

type PaymentMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  enabled: Boolean!
  configArgs: [ConfigArg!]!
  definition: ConfigurableOperationDefinition!
}

# "
# @description
# Permissions for administrators and customers. Used to control access to
# GraphQL resolvers via the {@link Allow} decorator.
#
# @docsCategory common
enum Permission {
  #  The Authenticated role means simply that the user is logged in
  Authenticated

  #  SuperAdmin can perform the most sensitive tasks
  SuperAdmin

  #  Owner means the user owns this entity, e.g. a Customer's own Order
  Owner

  #  Public means any unauthenticated user may perform the operation
  Public
  CreateCatalog
  ReadCatalog
  UpdateCatalog
  DeleteCatalog
  CreateCustomer
  ReadCustomer
  UpdateCustomer
  DeleteCustomer
  CreateAdministrator
  ReadAdministrator
  UpdateAdministrator
  DeleteAdministrator
  CreateOrder
  ReadOrder
  UpdateOrder
  DeleteOrder
  CreatePromotion
  ReadPromotion
  UpdatePromotion
  DeletePromotion
  CreateSettings
  ReadSettings
  UpdateSettings
  DeleteSettings
}

# The price range where the result has more than one price
type PriceRange {
  min: Int!
  max: Int!
}

type PriceRangeBucket {
  to: Int!
  count: Int!
}

input PriceRangeInput {
  min: Int!
  max: Int!
}

type Product implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
  featuredAsset: Asset
  assets: [Asset!]!
  variants: [ProductVariant!]!
  optionGroups: [ProductOptionGroup!]!
  facetValues: [FacetValue!]!
  translations: [ProductTranslation!]!
  collections: [Collection!]!
  recommendations: [ProductRecommendation!]!
  customFields: ProductCustomFields
}

type ProductCustomFields {
  productRecommendationsEnabled: Boolean
  groupKey: String
  seoDescription: String
}

input ProductFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  name: StringOperators
  slug: StringOperators
  description: StringOperators
  productRecommendationsEnabled: BooleanOperators
  groupKey: StringOperators
  seoDescription: StringOperators
}

type ProductList implements PaginatedList {
  items: [Product!]!
  totalItems: Int!
}

input ProductListOptions {
  skip: Int
  take: Int
  sort: ProductSortParameter
  filter: ProductFilterParameter
}

type ProductOption implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  groupId: ID!
  group: ProductOptionGroup!
  translations: [ProductOptionTranslation!]!
  customFields: JSON
}

type ProductOptionGroup implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  code: String!
  name: String!
  options: [ProductOption!]!
  translations: [ProductOptionGroupTranslation!]!
  customFields: JSON
}

type ProductOptionGroupTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductOptionTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type ProductRecommendation {
  product: Product!
  recommendation: Product!
  type: RecommendationType!
}

input ProductSortParameter {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  slug: SortOrder
  description: SortOrder
  productRecommendationsEnabled: SortOrder
  groupKey: SortOrder
  seoDescription: SortOrder
}

type ProductTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
  slug: String!
  description: String!
}

type ProductVariant implements Node {
  id: ID!
  product: Product!
  productId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  sku: String!
  name: String!
  featuredAsset: Asset
  assets: [Asset!]!
  price: Int!
  currencyCode: CurrencyCode!
  priceIncludesTax: Boolean!
  priceWithTax: Int!
  taxRateApplied: TaxRate!
  taxCategory: TaxCategory!
  options: [ProductOption!]!
  facetValues: [FacetValue!]!
  translations: [ProductVariantTranslation!]!
  bulkDiscounts: [BulkDiscount!]!
  customFields: ProductVariantCustomFields
}

type ProductVariantCustomFields {
  bulkDiscountEnabled: Boolean
  minimumOrderQuantity: Int
}

input ProductVariantFilterParameter {
  createdAt: DateOperators
  updatedAt: DateOperators
  languageCode: StringOperators
  sku: StringOperators
  name: StringOperators
  price: NumberOperators
  currencyCode: StringOperators
  priceIncludesTax: BooleanOperators
  priceWithTax: NumberOperators
  bulkDiscountEnabled: BooleanOperators
  minimumOrderQuantity: NumberOperators
}

type ProductVariantList implements PaginatedList {
  items: [ProductVariant!]!
  totalItems: Int!
}

input ProductVariantListOptions {
  skip: Int
  take: Int
  sort: ProductVariantSortParameter
  filter: ProductVariantFilterParameter
}

input ProductVariantSortParameter {
  id: SortOrder
  productId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  sku: SortOrder
  name: SortOrder
  price: SortOrder
  priceWithTax: SortOrder
  bulkDiscountEnabled: SortOrder
  minimumOrderQuantity: SortOrder
}

type ProductVariantTranslation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  languageCode: LanguageCode!
  name: String!
}

type Promotion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  startsAt: DateTime
  endsAt: DateTime
  couponCode: String
  perCustomerUsageLimit: Int
  name: String!
  enabled: Boolean!
  conditions: [ConfigurableOperation!]!
  actions: [ConfigurableOperation!]!
}

type PromotionList implements PaginatedList {
  items: [Promotion!]!
  totalItems: Int!
}

type Query {
  # The active Channel
  activeChannel: Channel!

  # The active Customer
  activeCustomer: Customer

  # The active Order. Will be `null` until an Order is created via `addItemToOrder`. Once an Order reaches the
  # state of `PaymentApproved` or `PaymentSettled`, then that Order is no longer considered "active" and this
  # query will once again return `null`.
  activeOrder: Order

  # An array of supported Countries
  availableCountries: [Country!]!

  # A list of Collections available to the shop
  collections(options: CollectionListOptions): CollectionList!

  # Returns a Collection either by its id or slug. If neither 'id' nor 'slug' is speicified, an error will result.
  collection(id: ID, slug: String): Collection

  # Returns a list of eligible shipping methods based on the current active Order
  eligibleShippingMethods: [ShippingMethodQuote!]!

  # Returns information about the current authenticated User
  me: CurrentUser

  # Returns the possible next states that the activeOrder can transition to
  nextOrderStates: [String!]!

  # Returns an Order based on the id. Note that in the Shop API, only orders belonging to the
  # currently-authenticated User may be queried.
  order(id: ID!): Order

  # Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)
  # this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation
  # screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing
  # general anonymous access to Order data.
  orderByCode(code: String!): Order

  # Get a Product either by id or slug. If neither 'id' nor 'slug' is speicified, an error will result.
  product(id: ID, slug: String): Product

  # Get a list of Products
  products(options: ProductListOptions): ProductList!

  # Search Products based on the criteria set by the `SearchInput`
  search(input: SearchInput!): SearchResponse!
  productRecommendations(productId: ID!): [ProductRecommendation!]!
  productBulkDiscounts(productId: ID!): [BulkDiscount!]!
  productBySlug(slug: String!): Product
}

enum RecommendationType {
  CROSSSELL
  UPSELL
}

type Refund implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  items: Int!
  shipping: Int!
  adjustment: Int!
  total: Int!
  method: String
  state: String!
  transactionId: String
  reason: String
  orderItems: [OrderItem!]!
  paymentId: ID!
  metadata: JSON
}

input RegisterCustomerInput {
  emailAddress: String!
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  password: String
}

type ResellerDiscount {
  facetValueIds: [ID!]!
  discount: Int!
}

type Return implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  orderItem: OrderItem!
}

type Role implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  description: String!
  permissions: [Permission!]!
  channels: [Channel!]!
}

type RoleList implements PaginatedList {
  items: [Role!]!
  totalItems: Int!
}

type Sale implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
  orderLine: OrderLine!
}

input SearchInput {
  term: String
  facetValueIds: [ID!]
  facetValueOperator: LogicalOperator
  collectionId: ID
  collectionSlug: String
  groupByProduct: Boolean
  take: Int
  skip: Int
  sort: SearchResultSortParameter
  priceRange: PriceRangeInput
  priceRangeWithTax: PriceRangeInput
}

type SearchReindexResponse {
  success: Boolean!
}

type SearchResponse {
  items: [SearchResult!]!
  totalItems: Int!
  facetValues: [FacetValueResult!]!
  prices: SearchResponsePriceData!
}

type SearchResponsePriceData {
  range: PriceRange!
  rangeWithTax: PriceRange!
  buckets: [PriceRangeBucket!]!
  bucketsWithTax: [PriceRangeBucket!]!
}

type SearchResult {
  sku: String!
  slug: String!
  productId: ID!
  productName: String!
  productPreview: String!
    @deprecated(reason: "Use `productAsset.preview` instead")
  productAsset: SearchResultAsset
  productVariantId: ID!
  productVariantName: String!
  productVariantPreview: String!
    @deprecated(reason: "Use `productVariantAsset.preview` instead")
  productVariantAsset: SearchResultAsset
  price: SearchResultPrice!
  priceWithTax: SearchResultPrice!
  currencyCode: CurrencyCode!
  description: String!
  facetIds: [ID!]!
  facetValueIds: [ID!]!

  # An array of ids of the Collections in which this result appears
  collectionIds: [ID!]!

  # A relevence score for the result. Differs between database implementations
  score: Float!
}

type SearchResultAsset {
  id: ID!
  preview: String!
  focalPoint: Coordinate
}

# The price of a search result product, either as a range or as a single price
union SearchResultPrice = PriceRange | SinglePrice

input SearchResultSortParameter {
  name: SortOrder
  price: SortOrder
}

type ServerConfig {
  orderProcess: [OrderProcessState!]!
  permittedAssetTypes: [String!]!
  customFieldConfig: CustomFields!
}

type ShippingMethod implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  description: String!
  checker: ConfigurableOperation!
  calculator: ConfigurableOperation!
  customFields: JSON
}

type ShippingMethodList implements PaginatedList {
  items: [ShippingMethod!]!
  totalItems: Int!
}

type ShippingMethodQuote {
  id: ID!
  price: Int!
  priceWithTax: Int!
  description: String!
  metadata: JSON
}

# The price value where the result has a single price
type SinglePrice {
  value: Int!
}

enum SortOrder {
  ASC
  DESC
}

type StockAdjustment implements Node & StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
}

interface StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  productVariant: ProductVariant!
  type: StockMovementType!
  quantity: Int!
}

union StockMovementItem = StockAdjustment | Sale | Cancellation | Return

type StockMovementList {
  items: [StockMovementItem!]!
  totalItems: Int!
}

enum StockMovementType {
  ADJUSTMENT
  SALE
  CANCELLATION
  RETURN
}

type StringCustomFieldConfig implements CustomField {
  name: String!
  type: String!
  list: Boolean!
  length: Int
  label: [LocalizedString!]
  description: [LocalizedString!]
  readonly: Boolean
  internal: Boolean
  pattern: String
  options: [StringFieldOption!]
}

type StringFieldOption {
  value: String!
  label: [LocalizedString!]
}

input StringOperators {
  eq: String
  contains: String
}

type TaxCategory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type TaxRate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  enabled: Boolean!
  value: Float!
  category: TaxCategory!
  zone: Zone!
  customerGroup: CustomerGroup
}

type TaxRateList implements PaginatedList {
  items: [TaxRate!]!
  totalItems: Int!
}

input UpdateAddressInput {
  id: ID!
  fullName: String
  company: String
  streetLine1: String
  streetLine2: String
  city: String
  province: String
  postalCode: String
  countryCode: String
  phoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  customFields: JSON
}

input UpdateCustomerInput {
  title: String
  firstName: String
  lastName: String
  phoneNumber: String
  customFields: JSON
}

input UpdateOrderInput {
  customFields: JSON
}

# The `Upload` scalar type represents a file upload.
scalar Upload

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  identifier: String!
  verified: Boolean!
  roles: [Role!]!
  lastLogin: DateTime
  authenticationMethods: [AuthenticationMethod!]!
  customFields: JSON
}

type Zone implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  members: [Country!]!
}
